import groovy.json.JsonSlurper

def call(Closure body) {

    withCredentials([usernamePassword(
            credentialsId: env.githubJenkinsCreds,
            passwordVariable: 'GITHUB_PASSWORD',
            usernameVariable: 'GITHUB_USER')]) {

        // create release notes
        def gitLog = '* _**No Commits Exist**_'
        try {
            gitLog = sh(script: '''
                # If there is no initial release (version) tag, grab all commit logs, otherwise, just since last release tag
                # LATEST_RELEASE_VER is set by getProdReleaseVer == GitHub releases/latest 
                if [ -n "${LATEST_RELEASE_VER}" ]; then
                  LOG_RANGE="${LATEST_RELEASE_VER}..."
                fi
                
                HREF="https://github.com/${GIT_ORG_REPO}/commit/%H"
                git log ${LOG_RANGE} --pretty=format:"* [%s](${HREF})" | grep -v Merge
            ''', returnStdout: true).trim()
        } catch(Exception e) {
            // git log will fail if the version tag in LOG_RANGE does not exist
            //   fatal: ambiguous argument '1.18.0...': unknown revision or path not in the working tree.
            //   Use '--' to separate paths from revisions, like this:
            //   'git <command> [<revision>...] -- [<file>...]'
            // We will eat that error to not fail the build
            echo """ERROR: No commits found since version tag ${env.RELEASE_VER}
===> The GitHub release notes will not contain a commit list. 
===> Usual cause: you did not merge 'master'/'candidate' to 'release' so git history is not up to date in 'release'.
===> You can debug locally, by checking out 'release' and running
===>   git log ${env.LATEST_RELEASE_VER} --pretty=format:\"* [%s](https://github.com/${env.GIT_ORG_REPO}/commit/%H)\" | grep -v Merge
"""
        }

        // Release notes are REALLY sensitive to leading spaces. If a line has leading spaces, GitHub
        // will interpret that as an inline code block - even if using html.
        env.releaseNotes = """### Commits for ${env.RELEASE_VER}

${gitLog}

_See the [CHANGELOG](https://github.com/${env.GIT_ORG_REPO}/CHANGELOG.md) for more details._
""".replaceAll(/"/) { '\\"' }.replaceAll(/\n/) {'\\n'}

        // create the GitHub release
        retryWithDelay {
            // TODO: convert this to groovy
            def jsonString = sh(script:''' 
                DATA='{\"tag_name\":"'\"${RELEASE_VER}\"'",\"target_commitish\":\"release\",\"name\":"'\"${RELEASE_VER}\"'",\"body\":"'\"${releaseNotes}\"'"}'
                response=$(curl -u ${GITHUB_USER}:${GITHUB_PASSWORD} -w "http_code=%{http_code}\n" --data "${DATA}" https://api.github.com/repos/${GIT_ORG_REPO}/releases)

                http_code=$(echo "${response}" | grep http_code | cut -f2 -d"=")
                if [ ${http_code} -lt 200 -o ${http_code} -ge 300 ]
                then
                    exit 1
                fi

                echo "${response}" | grep -v http_code
            ''', returnStdout: true).trim()

            def latestRelease = new JsonSlurper().parseText(jsonString)
            env.RELEASE_ID = latestRelease.id
            latestRelease = null // must discard due to not being serializable
        }

        // add build timestamp for duplicate deploy detection
        retryWithDelay {
            sh '''
                # Record the build timestamp for this release so on subsequent job runs, we can tell
                # that this image has already been released.

                DOCKER_BUILD_TIMESTAMP=$(docker inspect --format='{{ index .ContainerConfig.Labels "com.makara.build.timestamp" }}' ${DOCKER_IMAGE_BASENAME}-${releaseType}:latest)
                echo -n > /tmp/build-info.txt
                echo "# DO NOT MODIFY: Auto-generated by Jenkins during the build" >> /tmp/build-info.txt
                echo "BUILD_TIMESTAMP=${DOCKER_BUILD_TIMESTAMP}" >> /tmp/build-info.txt

                response=$(curl --data-binary @/tmp/build-info.txt  -u ${GITHUB_USER}:${GITHUB_PASSWORD} -w "http_code=%{http_code}" -H "Content-Type: text/plain"  https://uploads.github.com/repos/${GIT_ORG_REPO}/releases/${RELEASE_ID}/assets?name=build.${DOCKER_BUILD_TIMESTAMP})
                http_code=$(echo "${response}" | grep http_code | cut -f2 -d"=")
                if [ ${http_code} -lt 200 -o ${http_code} -ge 300 ]
                then
                    echo "Release ${RELEASE_ID} was created but we failed to create the build asset."
                    echo "You can add asset build.${DOCKER_BUILD_TIMESTAMP} to v${RELEASE_VER} manually or create a new release."
                    exit 1
                fi
            '''
        }
    }
}
return this
